0415 공부

제네릭

2.명식적 타입 지정
가끔 컴파일러의 추론이 원하는 타입과 다르게 작동할 수 있거나
호출 시점에 타입을 명확히 지정하여 코드 가독성을 높이고자 할 떄 사용한다
타입을 명식적으로 지정하면 오류를 방지하고 의도를 명확히 할 수 있다

제네릭 타입은 상하관계가 없다

불공변성
타입간 상속관계가 있어도, 제네릭으로 감싸진 타입은
서로 별개의 타입으로 취급된다
이를 통해 예상치 못한 타입 혼란과 런타임 오류를
미연에 방지할 수 있다. 

제네릭 와일드 카드
<?> : 어떤 타입이든 될 수 있다는 의미
그냥 ?만 사용하게 되면 <object>쓰는 것과
다름이 없어지므로 보통 제네릭 타입 한정 연산자와 같이 쓰인다.
<? extends 상위타입>: 상위타입의 하위 개념은 다 들어올 수 있다.
읽기 작업에 적합하다(컬렉션에서 읽은 값이 최소 number타입으로
ex) <? super Integer> -> integer,Number, Object는 전부 들어올 수 있다
쓰기 작업에 적합(최소 INteger를 보장한다)
Integer 타입은 안전하게 추가가 가능함 -> Number, Object

List<? extends Number> list = new ArrayList<>();
?에 정확한 타입이 뭐가 들어올지 모르기 때문에 추가할 수 없다
numList.add(100) // (null)은 가능 -> 타입이랑 상관이 없기 때문에

읽기 작업: 읽어온 값이 구체적인 타입을 보장받지 못하기 때문에
Object로 처리해야 한다.
Object value = list.get(0);

Interator가 리스트 원본의 주소를 참조한다
next() 메서드를 호출하면, 참조한 주소로 가서 요소를 직접 읽어온다

한번 사용한 Iterator객체는 재사용할 수 없다 

remvoe()
현재 Iterator가 가리키고 있는 욧오를 원본 리스트에서 제거한다

entrySet()
모든 key-value 쌍을 Map.Entry객체로 구성된Set 형태로

for(Map.Entry<String, integer> entry : entries) {

}

컬렉션
1.ArrayList
2.HashMap
3.HashSet

lamda
컴파일어한테 현재 인터페이스가
함수형인터페이스임을 알려주는 어노테이션

인터페이스를 함수형 인터페이스라고 선언한 순간
무조건 1개의 추상메서드만 들어갈 수 있다

연산식 : int value = 2*2+2;
람다식(lamda-Expression)
함수를 식처럼 사용하겠다
람다식을 왜 쓸까
코드가 간결해진다

람다식으로 구현하기
람다식은 함수의 선언부에서 매개변수 부분과 코드블럭 부분만 살린다
매개변수와 코드블럭 사이에 -> 를 쓰면 끝난다
(매개변수들) -> {실행할 코드; }

Calculator lamda = (int x, int y); -> {return x + y;};

System.out.println("람다식 : "+ lamda.f(10, 7));

람다식은 함수형 인터페이스를 구현한 객체라고 볼 수 있다
표면상으로는 new 키워드를 사용하지 않지만 일반적인
자바 객체들처럼 Heap영역에 할당이 된다

자바는 객체지향 언어로서 모든 메서드는 객체를 통해 이루어진다
람다식은 익명함수 처럼 보이지만 실제로는 함수형 인터페이스를
구현한 객체이기 때문에, 다른 메서들철머 추상 메서드의 이름으로
호출하는것이 자연스럽다

람다식을 반환값으로 받는 경우

자바에서 제공하는 함수형 인터페이스
Function<T, R>
추상메서드 R apply( T t)

predicate와 논리연산
and(), or(), negate();

참조연산자 ::
람다식 내부에서 메서드를 호출할 때 보다 간결하게
표현하기 위해서 사용하는 연산자

1. 정적 메서드 참조

2.인스턴스 메서드 참조

스트림 컬렉션(데이터들이 들어가있음)
데이터들을 하나씩 처리하는 방식이다
데이터를 저장한다기보다는 처리하는 기능에 집중이 되어있다.

특징 
1.선언형이다: 반복문없이 데이터 처리가 가능하다


2. 내부반복: 개발자가 직접 반복문을 작성하지 않는다(스트림 api 가 반복을 대신 처리해준다
3.불변성: 원본 데이터는 변경되지 않느다
4.자연연산: 최종 연산이 실행되기 전까지 중간 연산이 수행되지 않는다
5.최종연산까지 사용하고나면 스트림을 재사용할 수 없다

스트림 사용 방법
스트림을 생성한다
배열로부터 생성하는 것도 가능하다
컬렉션객체로부터 생성하는 것도 가능하다

중간연산
중간연산은 스트림을  변환하거나 필터링 하는 연산
새로운 스트림을 반환하며, 지연처리가 된다

distinct()
중복을 제거해준다

peek()
값을 그대로 유지하면서 중간에 볼 수 있다


























