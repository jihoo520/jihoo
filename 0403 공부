0403

public interface menu1
인터페이스는 상수와 추상메서드, default메서드만 들어갈 수 있다
상수
값을 한 번 넣으면 변경이 불가능 함
추상메서드 -> 구현체({}) 가 없는 메서드
default메서드 -> default접근 제한다를 가진 완전한 메서드
final String

인터페이스를 구현한 클래스는 반드시 추상메서드를
오버라이드 해야한다

인터페이스는 객체를 직접 생성할 수 없다
인터페이스를 구현한 클래스의 객체를 생성한다

부모타입으로 자동 타입변환을 할 수 있다
부모타입으로부터 만들어진 메서드만 사용할 수 있다

멤버변수는 private으로 지정하는 일이 많기 떄문에 직접 접근하는 것이 불가능 하다
public 으로 된 메서드를 통해서 접근을 하는일이 많다
setter & gettter

익명클래스
이름이 없는 클래스
일회성으로 사용되는 클래스를 간단하게 정의할 수 있다
인터페이스낭 추상클래스의 구현을 간단하게 처리할 수 있다.

함수형 인터페이스
익명클래스보다 람다식 더 간단하기 때문에 함수형 인터페이스를
사용할 떄는 람다식 더 권장된다

직접 인터페이스를 만들일은 적고, 자바에서 제공하는 인터페이스를
사용하는 일이 더 많다

Collection -> 자바에서 제공하는 인터페이스
↓
List,             Set              Map            ->인터페이스
↓                  ↓                ↓
ArrayList       HashSet            HashMap        ->구현된 메서드
LinkLIst        Treeset
Vector

ArrayList
인덱스를 가지고있다
배열을 기반으로 동작한다
배열과 다른점은 데이터를 넣는대로 들어간다
조회에는 유리하다(index에 바로 접근하니깐)
추가/삭제에는 불리하다 (상대적으로)

Linked List
노드를 기반으로 동작
노드: 데이터와 다음 노드의 주소를 가지고 있는 객체
인덱스가 없음
조회에는 불리
추가/삭제에 유리하다

HashSet
인덱스가 없다
정렬이 되지 않는다
중복이 없다

HashMap
key-value 쌍으로 이루어져 있다
index가 없다
대량의 데이터를 저장할 때 좋다

컬렉션은 중첩해서 사용할 수 있다

HashMap<String, List<String>>map

list,set
add()-> 데이터의 추가
set()-> 데이터의 수정
remove()-> 데이터의 삭제
clear() -> 컬렉션 내부의 데이터 전체 삭제
isEmpty()-> 비어있는지 판별
get()-> value  값 가져오기


HashMap
put()
get()
getofDefault()
putIfabsent()
remove()
isEMpty()

Col
람다식
함수를 값처럼 사용해서 변수에 대입할 수 있다

람다식을 작성하기 위해서는 함수형 인터페이스가 반드시 필요한다

자료형을 생략할 수 있다
(x, y) -> {return x + Y;}

return 과 중괄호는 같이 생략할 수 있다
(x, Y) -> x + y;

매개변수가 하나일 때는 소괄호도 생략이 가능하다
x -> System.out.println(x)

매개변수가 하나고 명령이 하나면 ::연산자를 사용해서 더 줄일 수 있다

System.out::println

우리가 직접 함수형 인터페이스를 생성할 수 도 있지만
컬렉션에 속해있는 메서드에 매개변수로 사용되는 일이 더 많다

람다식의 참조연산자(::)
람다식을 더 간결하게 표현하기 위한 문법

s -> System.out.println(s)

System.out::println

종류와 형식
정적 메서드 참조    
클래스명:: 정적메서드명                  
integer::paeselnt

인스턴스 메서드      
참조 참조변수::인스턴스 메서드          
System.out::println


특정 타입의 인스턴스 메서드 참조
클래스명::인스턴스 메서드
String::toUpperCase

생성자 참조
클래스명::new
ArrayList::new

스트림의 특징
데이터를 하나씩 순회하면서 반복할거면 iterator를 쓰면 되는데 왜 스트림을 써야 하냐

데이터 처리 파이프라인을 구성해서 선언형으로 데이터를 처리할 수 있다.

선언형
for(String name: name){
if(name.length() > 3){
  System.out.println(name);
}
}

선언형
names.Stream()
    .메서드()
    .메서드()
    .메서드()
    .메서드()
    .메서드()

내부반복
개발자가 반복을 제어하지 않고, 스트림이 알아서 요소들을 반복하면서 처리하는 방법
어떻게 반복할지는 스트림이 정하고, 반복하면서 무엇을 할지를 정하면 된다

지연연산(Lazy Evaluation)
-중간 연산은 최종 연산이 실행되기 전까지 아무 일도 하지 않는다
-최종 연산이 호출될 때까지 연기되는 처리방식이다.

불변성
-원본데이터는 변하지 않는다

일회성
-스트림은 최종연산이 끝나면 다시 중간연산을 할 수 없다

최종연산
스트림 파이프라인의 마지막에 실행되는 연산
스트림이 소비되고
실제 데이터가 처리된다
중간 연산들을 실행하게 하는 트리거이자 스트림의 결과를 만드는 연산

특징
-스트림을 종료시키며, 다시 사용할 수 없다
-값을 반환한다



























