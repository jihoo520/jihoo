map 메서드
배열에 들어있는 요소들을 하나씩 순회하면서 변화를 주고싶을때

reduce메서드
배열의 모든 요소를 하나의 값으로 누적해주는 함수
array.reduce((누적값,현재 값) => {return 새로운 누적값}, 초기값);
누적값: 이전 반복에서 반환 받은 값
현재 값: 현재 순회중인 배열의 요소
초기 값: 누적 값의 초기 값(생략하면 배열의 첫 번째 요소가 초기 값)

forEach() -> 하나씩 출력(콘솔에 출력할 때 많이 사용)
map()-> 각 요소를 변환해서 새로운 배열을 반환
filter() -> 조건을 만족하는 요소만 남긴다
reduce() -> 누적 계산을 수행
some() -> 하나라도 조건을 만족하면 true
every() -> 모두가 조건을 만족해야 true
find() -> 조건에 맞는 첫 번째 요소를 반환

반복문이나 조건문(if)를 가지고 로직처리했다

리액트 or 리액트 네이티브
조건부 렌더링이 매우 자주 필요하다
삼항연산자, 논리연산자를 많이 사용을 하고 있다
JSX는 HTML이랑 JavaScript가 섞인 형태이지만
JSX안에서는 if문을 직접 사용할 수 없다
따라서 삼항연산자나 논리연산자를 이용해야만 한다

삼항연산자
명확한 두 가지 경우의 처리

논리연산자
조건을 만족할 때만 랜더링 할때

천 번째 인자: 계산 로직이 담긴 함수

메모제이션
함수의 결과값을 어딘가에 저장해뒀다가 같은 입력이 들어오면 다시 계산하지 않고 저장된 값을 재사용하는 기법

리액트 내부의 훅 저장소에 그 컴포넌트 객체에 견결된 형태로 값이 저장된다

JS힙 메모리에 저장이 된다

커스텀 훅
여러 컴포넌트에서 사용하는 로직을 재사용 가능한 함수로 만들 수 있다
복잡하거나 반복되는 훅 사용 코드를 조합해서 나만의 훅으로 만드는 것
이름은 반드시 use~로 시작해야 한다
왜냐하면 리액트가 해당 함수를 훅으로 인식할 수 있도록 하기 위함이다

Conext API 
상태를 전역적으로 관리 할 수 있다

최상위 컴포넌트에서 하위 컴포넌트를 많이 거쳐야 할 때 중간단계  컴포넌트들을 거쳐야 하는 문제가 있었다

특정 데이터를 사용하지 않는 중간 컴포넌트드고 props를 반은 다음에 자식 컴포넌트로 전달해야 하기 때문에
코드가 복잡해지고 가독성이 떨어지며, 유지보수가 어려워진다

컴포넌트가 특정 데이터와 강하게 결합이되면 해당 컴포넌트를 다른 곳에서 사용하기가 어려워진다
개별적으로 사용하려고 만든 컴포넌트인데 독립적으로 사용하는 것이 어려워질 수 있다

상태의 관리와 동기화에 어려움
상태가 상위 컴포넌트에 위치하고, 컴포넌트의 계층이 깊을 수록 상태를 업데이트하는 과정이 복잡해진다

상위에서 하위로 데이터를 전달하는 과정에서 버그가 발생할 가능성이 있다

불필요한 재랜더링
상위 컴포넌트의 상태가 변경되면, 해당 상태를 전달 받는 모든 하위 컴포넌트가 재랜더링 된다
계층이 깊어진면, 상태를 직접적으로 사용하지 않는 중간 컴포넌트까지 재랜더링 될 수 있다
이로 인해 성능이 저하되고, 어플리케이션이 느려질 수 있다

provider 컴포넌트는  value 를 받아서 모든 하위 컴포넌트에 전달하고, 하위 컴포넌트는 value가 변경도리 때마다 
다시 랜더링 된다

App 컴포넌트를 Rrovider 컴포넌트로 감쌌기 때문에 User 컴포넌트에서 사용된
Cosumer 컴포넌트는 더이상 Context의 기본값을 사용하지 않고 provider 컴포넌트가 전달하는
데이터를 사용하도록 변경되었습니다

Provier 컴포넌트에서는 어떤 값도 전달되지 않고  consumer 컴포넌트의 자식으로 지정된 함수의 파라미터로
undefined 가 전달되면서 오류메시지가 나타난다
이 문제는 provider 컴포넌트의 value에 값을 전달하여 해결할 수 있다



























