0512

post -> @Requestbody로 받아줌

조회
요청 -> 컨틀롤러 -> 서비스 -> 레파지토리 -> DB -> 레파지토리 -> 서비스 -> 컨트롤러 -> 응답

추가
요청 -> 컨틀롤러 -> 서비스 -> 레파지토리 -> DB -> 레파지토리 -> 서비스 -> 컨트롤러 -> 응답

수정
요청 -> 컨틀롤러 -> 서비스 -> 레파지토리 -> DB -> 레파지토리 -> 서비스 -> 컨트롤러 -> 응답

삭제
요청 -> 컨틀롤러 -> 서비스 -> 레파지토리 -> DB -> 레파지토리 -> 서비스 -> 컨트롤러 -> 응답

같은 매커니즘으로 돌아가는 구조

백엔트로 데이터를 전달하는 방법
백엔드로 요청을 할 때는 항상 axios.fetch를 사용을 한다
요청 url 에 적으면 된다

모든 기능을 우리가 다 만들 수는 없다

각자 기업에서 제공해 주는 기능에 우리가 접근을 해서 사용

1.@PathVariable
주소의 일부를 변수로 받는거

@RestController

REST

2.@ReauestParam
쿼리스트링으로 넘어오는 데이터를 매개변수에 전달
쿼리스트링: URL에서 뒤에 붙는 추가 정보
주로 키 = 값으로 구성되며 여러개일 떄는 &로 구분한다
웹서버나 어플리케이션에 매개변수를 전달할 떄 자주 사용한다

선택적 필터링이나 정렬, 페이징처리에 적합하다
required = false설정으로 선택적으로 파라미터를 받을 수 있다
기본값 제공이나 옵션 처리에 용이하다

POST로 데이터를 전달할 때는 body 에 실어서 보낸다
url에 리소스가 있다면 @PathVariable로 받을 수 있다
하지만 쿼리스트링으로 데이터가 전달되지는 않는다

리액트에서 스프링부트로 데이터를 전달할 때 JSON으로 보낸다
{"키":"값"} -> JSON

@PostMapping("/users/{name}")




직렬화
자바 객체를 JSON문자열로 변환하는 과정
네트워크 전송, 파일 저장 등 바이트 스트림이나 텍스트 형태로 
객체를 외부로 내보낼  때 사용
@ResponseBody
역 직렬화
JSON 문자열을 자바 객체로 변환하는 과정
외부에서 전달받은 JSON 데이터를 자바 객체로 복원할 떄 사용
@RequestBody

CSRF
사용자가 이미 로그인한 웹사이트의 세션 쿠키를

회원가입 2명을 했다

첫번쨰 사용자로 로그인한 후 토큰을 복사한다
/todo에 POST메서드를 사용해서 할 일을 하나 추가한다
두 번째 사용자로 로그인을 한 후 위와 같이 반복한다
이때 첫 번째 사용자가 추가한 할일은 보이지 않아야 한다

프론트엔드 통합
프론트앤드 어플리케이션은 이제부터 백엔드 HTTP요청을 보낼때
403이 날아오면 토큰을 어딘가에 저장해 놓고 로그인 페이지로 리다이렉트 해야한다
저장해놓은 토큰을 HTTP요청을 보낼 떄마다 헤더에 Bearer토큰으로 지정해줘야 한다






























