0425 공부

오버로딩
같은 클래스에서 같은 이름의 메서드 매개변수의 개수나 타입을 다르게 해서 여러번 정의하는 것(중복정의)0

오버라이딩
상속관계에서 부모 클래스에 정의된 메서드를 자식클래스에서 재정의하는 것
메서드명이나 매개변수의 타입, 개수는 모두 같고 내용만 자식클래스의 상황에 따라 재정의 한다(재정의)

함수의 작동원리
1.함수를 선언한다
2.함수를 호출한다(인자로 전달할거 있으면 같이 전달
3.함수를 선언한 쪾으로 올라가서 기능을 실행한다
4.함수안의 모드느 내용이 끝나면 호출한 쪽으로 돌오와서 아래에 코드가 있으면 계속 진행

const promise = new Promise((resolve,reject) => {})


promise체이닝
여러 비동기작업을 순차적으로 연결할 때 유용하다
.then()
.catch()
.finally()

3.async/awiat

async: 함수 앞에 async키워드를 붙임으로서 해당 함수를 비동기적함수로 만드는 효과가 있다

비동기함수는 무조건  Promise객체를 반환한다

await: 비동기 함수 안에서 사용하는 키워드 Promise가 처리될 때 까지 함수의 실행을 일시적으로 중지한다

const fetchData() => {
return new Promise((resolve) => {

함수를 실행하고 받은 결과는 prommise 객체이다

요청과 응답
요청: reaquest 클라이언트가 서버에게 화면이나 데이터를 달라고 요청
HTTP요청메서드
GET
POST
PUT

응답: response 서버가 클라이언트에게 데이터를 주거나 화면을 돌려준다

Redux
상태 관리 라이브러리 어플리케이션의 전역 상태를 관리하느데 도움을 준다
복잡한 리액트 어플리케이션에선는 여러 컴포넌트간 상태 공유가 어렵기 때문에
Redux를 사용해 중앙 집중화된 store를 통해 상태를 효율적으로 관리할 수 있다

핵심개념
스토어
어플리케이션의 전역 상태를 관리하는 곳
createStore 함수를 사용하여 스토어를 생성하고 어플리케이션 전반에서 상태를
유지하고 관리하는 역할

액션
상태를 변경하기 위해 발생시키는

리듀서
-상태를 변경하는 함수
-현재 상태와 액션을 인자로 받아 새로운 상태를 반환
-이 과정에서 상태를 직접 수정하지 않고, 항상 새로운 상태 객체를 반환하는 것이 중요하다

디스패치
액션을 스토어에 전달하는 메서드
-컴포넌트에서 디스패치를 통해 액션을 발생시키고, 리듀서가 상태를 업데이트하도록 한다

Redux의 필요성
상태를 중앙에서 관리하여 컴포넌트 간의 의존성을 줄이고, 상태 관리가 보다 예측 가능하고 유지보수하기 쉬워진다

Redux의 동작 원리
1. 스토어의 생성: 애플리케이션의 state를 보관할 스토어를 생성한다
2.액션 디스패치: 사용자가 기타 이벤트에 따라 액션을 디스패치한다
3.리듀서 호출: 디스패치된 액션을 리듀서가 받아 새로운 state를 계산한다
4.상태 업데이트: 스토어의 state가 업데이트되고, 이를 사용하고 있는 컴포넌트들이 리렌더링 된다

Redux를 선택할 때
애플리케이션의 상태 관리가 복잡하거나 규모가 큰 경우 
상태 변경 로직을 명확하게 분리하고 싶을 때

Context APi를 선택할 때
상태관리가 비교적 간단하고 작은 규모의 프로젝트일때
추가적인 라이브러리 설치 없이 빠르게 전역 상태를 관리하고 싶을때
성능 최적화가 크게 필요하지 않은 경우

react-redux
React에서 redux를 쉽게 사용할 수 있도록 돕는 바인딩 라이브러리이다

Provider 컴포넌트
어플리케이션 전체에 스토어를 제공한다
최상위 컴포넌트를 감사써 모든 자식 컴포넌트가 Redux 스토어에 접근할 수 있도록 해준다

useSselector
redux스토어에서 상태를 선택하고 React 컴포넌트에서 사용할 수 있게 한다
스토어의 특정 상태를 선택해서 가져올 수 있다

useDispatch
액션을 디스패치 하는 함수로, 컴포넌트에서 액션을 발생시켜 상태를 변경할 수 있게 한다



























