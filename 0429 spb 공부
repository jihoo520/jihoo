디자인 패턴
소프트웨어 설계과정에서 반복적으로 발생하는 문제를 해결하기 위한 재사용 가능한 설계 기법이다
특정 언어나 플랫폼에 종속되는것이 아니라, 상황과 해법의 구조를 문서화한 유연한 설계도라고 생각하면 된다

작문하는 방법

싱글톤 패턴
스프링이 직접 관리하도록 시킨 클래스는 메모리에 무조건 한번만 올라간다
사용할 때는 메모리에 올라가 있는 객체를 받아서 사용한다

팩토리 패턴
객체 생성 록직을 별도의 클래스로 분리하여 , 클라이언트 코드가 구체적인 클래스에 의존하지 않도록 만드는 패턴

롬복(lombok)
-어노테이션 기반의 코드 생성 라이브러리이다
자바 클래스에서 반복생성되는 코드 생성자 를 자동으로 생성해준다
-컴파일 시점에 어노테이션이 코드를 주입하므로 실제 소스 파일에는 메서드 구현이 보이지 않는다

주요 어노테이션 및 역할
@Getter/ @Setter: 필드별 getter/setter 메서드 생성
@ToString: toString() 메서드 자동 생성
@EqulasAndHashCode: equals & hashCode() 메서드 생성
@NoArgsConstructor: 파라미터 없는 생성자 생성
@AllArgsConstructor: 모든 필드를 파라미터로 받는 생성자 생성
@RequiredArgsConstructor: final또는 @NonNull필드만 파라미터로 받는 생성자 생성
@Builder: 빌더 패턴을 지원하는 빌드 클래스를 생성

의존성 주입프트웨어 설계과정에서 반복적으로 발생하는 문제를 해결하기 위한 재사용 가능한 설계 기법이다
특정 언어나 플랫폼에 종속되는것이 아니라, 상황과 해법의 구조를 문서화한 유연한 설계도라고 생각하면 된다

작문하는 방법

싱글톤 패턴
스프링이 직접 관리하도록 시킨 클래스는 메모리에 무조건 한번만 올라간다
사용할 때는 메모리에 올라가 있는 객체를 받아서 사용한다

팩토리 패턴
객체 생성 록직을 별도의 클래스로 분리하여 , 클라이언트 코드가 구체적인 클래스에 의존하지 않도록 만드는 패턴

롬복(lombok)
-어노테이션 기반의 코드 생성 라이브러리이다
자바 클래스에서 반복생성되는 코드 생성자 를 자동으로 생성해준다
-컴파일 시점에 어노테이션이 코드를 주입하므로 실제 소스 파일에는 메서드 구현이 보이지 않는다

주요 어노테이션 및 역할
@Getter/ @Setter: 필드별 getter/setter 메서드 생성
@ToString: toString() 메서드 자동 생성
@EqulasAndHashCode: equals & hashCode() 메서드 생성
@NoArgsConstructor: 파라미터 없는 생성자 생성
@AllArgsConstructor: 모든 필드를 파라미터로 받는 생성자 생성
@RequiredArgsConstructor: final또는 @NonNull필드만 파라미터로 받는 생성자 생성
@Builder: 빌더 패턴을 지원하는 빌드 클래스를 생성

의존성 주입

필드주입
클래스의 필드에 @Autowired를 붙여, 스플링이 직접 주입해주는 방식
setter나 생성자 없어도 간단히 주입할 수 있다는 특징이 있다
장점: 필드 선언부에 어노테이션만 붙이면 되므로, 다른 코드가 거의 필요가 없다

단점: 코드만 보고는 어떤 의존성이 언제 주입되는지 파악하기 어렵다
불변성 미보장 - 초기화 전 필드가 null일 수 있다

생성자 주입(Consturctor Injection)
객체 생성 시점에 필요한 모든 의존성을 생성자의 매개변수로 받아
설정하는 방식

장점
블변성 보장
final 필드를 사용할 수 있어, 의존성이 반드시 주입된 상태로 객체가 생성된다
순환 참조 탐지
순환 의존성이 있을 때 애플리케이션 시작 시점에 바로 예외가 발생해 문제를 조기에 파악할 수 있다

단점
의존성이 많아지면 생성자 매개변수가 길어져 가독성이 떨어질 수 있다

세터주입(Setter injection)
setter메서드를 통해 의존성을 주입하는 방식

장점
의존성이 반드시 필요항지 않은 경우 세터를 통해 우연하게 주입 여부를 제어할 수 있다

Gradle
자바, 코틀린, 그루비(groovy)등 다양한 프로그래밍 언어를지원하는 빌드 자동화 도구이다

빌드자동화 도구란?
소스코드로부터 실행가능한 산출물을 생성하는 일련의 과정을 관리, 수행해주는 도구
컴파일, 테스트, 패키징, 배포 등 개발 과정의 반복작업을 스크립트 설정 파일로 정의해
사람의 수작업 없이 실행할 수 있게 해준다

Grdle의 주요 특징
1. 의존성 관리
Maven Central, JCenter, Ivy같은 의존성 저장소에서 외부 라이브러리를 쉽게 가져와 사용할 수 있도록 도와준다
이를 통해 개발자는 필요한 라이브러리를 직접 다운로드하지 않고
빌드시 자동으로 라이브러리를 다운로드하고 관리할 수있다

2.DSL
스크립트를 작성할 때 groovy나 코틀린을 사용한다
빌드로직을 간결하고 유연하게 작성할 수 있다

3.멀티프로젝트빌드
Gradle은 여러 프로젝트를 하나로 묶어 멀티 프로젝트 빌드를 전달한다

포스트맨 API테스트툴
REST API는 크게 나눠 URI, HTTP메서드, 요청 매게변수 또는 요청 바디로 구분이 되는데
이를 브라우저에서 테스트하는것에는 한계가 있다

테스트를 한다고 임시로 프론트엔드 UI를 만드는 것은 지속가능한 방법이 아니다

데이터 베이스 계층
dbms를 의미한다

보통 자바의 클래스 종류
기능을 수행하는 클래스 데이터를 담기 위한 클래스
기능을 하는 클래스: Controller, Service, Persistance
데이터를 담는 클래스: 모델, 엔티티

model은 데이터를 담는 역할과 db의 테이블과 스키마를 표현하는 두가지 역할을 한다

DTO(data transition object)
클라이언특가 데이터를 가지고 요청하거나 서비스가 요청을 처리하고
클라이언트가 반환할때 모델 자체를 그대로 반환하는 경우는 거의 없다
보통은 데이터를 전달하기 위해 사용하는 객체인 DTO로 변환해 반환한다

DTO로 변환해서 반환하는 이유
1. 비즈니스 로직의 캡술화
-외부인이 회사의 DB스키마를 아는것을 원한지 않는다
-이때 DTO 처럼 다른 객체로 바꿔 반환하면 외부 사용자에게 서비스 내부의 로직, DB구조 등을  숨길 수 있다

2.클라이언트가 필요한 정보를 모델이 전부 포함하지 않을 수 있다
-에러 메시지를 보내야할 때
-어디에 담아서 보내야 하는가?
-모델은 서비스 로직과는 관련이 없기 때문에 모델에 담는건 적합하지 않다
-이련경우 DTO에 실어서 보내는 것이 좋다

Rest API
REST아키텍처를 기반으로 하는 API

Rest API는 클라이언트와 서버 간의 상호작용을 HTTP를 사용해 설계한 웹 서비스 인터페이스로, 데이터를 쉽게 주고받을
수 있게 해준다

REST API는 웹 어플리케이션, 모바일 앱 등 다양한 시스템 간의 통신을 위한 표준으로 널리 사용되고 있다

REST 아키텍쳐 스타일은 6가지 제약조건으로 구성된다

이 가이드를 따르는 API를 RESTful API라고 한다

주요개념
클라이언트 - 서버
리소스를 관리하는 서버가 존재하고, 다수의 클라이언트가 리소슬르 소비하기 위해 네트워크를 통해 서버에 접근하는 구조

Stateless
클라이언트가 서버에 요청을 보낼때, 이전 요청의 영향을 받지 않음을 의미한다

일관적인 인터페이스
시스템 또는 어플리케이션의 리소스에 접근하기 위한 인터페이스가 일관적이어야 한다

HTTP 메서드 사용의 일관성

GET    /user   모든 사용자 목록 조회
GET    /users/{id}     특정 사용자를 조회
POST   /users       새로운 사용자 생성
PUT    /users/{id}사용자 정보 업데이트
DELETE   /users/{id}사용자 삭제

API 사용자들이 다양한 리소스와 상호작용할 때 동일한 패턴을 예상할 수 있다 

URI 구조의 일관성
URI 경로를 일관되게 설계하는 것도 중요하다
리소스의 이름은 복수형으로 일관되게 사용하고, 리소스 간 관계를 표현할 떄도 규칙적으로 작성해야 한다

모든 API의 응답형식도 일관되게 설계해야한다
예를 들어, 성공 시 HTTP상태 코드와 JSON 형식의 응답을 동일하게 유지하는게 좋다

레이어시스템
클라이언트가 서버에 요청을 날릴때 , 여러개의 레이어로 된 서버를 거칠 수 있다
클라이언트는 여러 레이어를 인지하지 않고, 최종적으로 서버에서 오는 응답만 신경쓰면 된다
서버 측에서는 각 레이어가 독립적으로 동작하며, 각각의 레이어가 맡은 역할을 수행해 확장성, 보안성, 성능 최적화가 
가능하다

Controller
클라이언트로부터 요청을 받아오거나, 서버로부터 응답을 내보내는 역할

@RestController
html같은 뷰 페이지를 반환하는 대신, JSON이나 XML형식의 데이터를 반환하는 RESTful API를 제공하는데 적합하다
























